/* tslint:disable */
/* eslint-disable */
/**
 * Time Tracker API
 * The Time Tracker API specification
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivityCreateFailedResponse
 */
export interface ActivityCreateFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof ActivityCreateFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityCreateFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ActivityCreateFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface ActivityCreateRequest
 */
export interface ActivityCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityCreateRequest
     */
    'resourceIdentifier': string;
    /**
     * 
     * @type {number}
     * @memberof ActivityCreateRequest
     */
    'timeSpent': number;
    /**
     * 
     * @type {string}
     * @memberof ActivityCreateRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityCreateRequest
     */
    'resourceType'?: ActivityCreateRequestResourceTypeEnum;
}

export const ActivityCreateRequestResourceTypeEnum = {
    Web: 'web',
    Mobile: 'mobile',
    Pc: 'pc'
} as const;

export type ActivityCreateRequestResourceTypeEnum = typeof ActivityCreateRequestResourceTypeEnum[keyof typeof ActivityCreateRequestResourceTypeEnum];

/**
 * 
 * @export
 * @interface ActivityCreateSuccessResponse
 */
export interface ActivityCreateSuccessResponse {
    /**
     * 
     * @type {number}
     * @memberof ActivityCreateSuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ActivityCreateSuccessResponse
     */
    'userId': number;
    /**
     * 
     * @type {ResourceFieldDto}
     * @memberof ActivityCreateSuccessResponse
     */
    'resource': ResourceFieldDto;
    /**
     * 
     * @type {number}
     * @memberof ActivityCreateSuccessResponse
     */
    'timeSpent': number;
    /**
     * 
     * @type {string}
     * @memberof ActivityCreateSuccessResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityCreateSuccessResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityCreateSuccessResponse
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ActivityFailedResponse
 */
export interface ActivityFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof ActivityFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ActivityFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface ActivitySuccessResponse
 */
export interface ActivitySuccessResponse {
    /**
     * 
     * @type {number}
     * @memberof ActivitySuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ActivitySuccessResponse
     */
    'userId': number;
    /**
     * 
     * @type {ResourceFieldDto}
     * @memberof ActivitySuccessResponse
     */
    'resource': ResourceFieldDto;
    /**
     * 
     * @type {number}
     * @memberof ActivitySuccessResponse
     */
    'timeSpent': number;
    /**
     * 
     * @type {string}
     * @memberof ActivitySuccessResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ActivitySuccessResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActivitySuccessResponse
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ActivityUpdateFailedResponse
 */
export interface ActivityUpdateFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof ActivityUpdateFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityUpdateFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ActivityUpdateFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface ActivityUpdateRequest
 */
export interface ActivityUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof ActivityUpdateRequest
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActivityUpdateRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ActivityUpdateSuccessResponse
 */
export interface ActivityUpdateSuccessResponse {
    /**
     * 
     * @type {number}
     * @memberof ActivityUpdateSuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ActivityUpdateSuccessResponse
     */
    'userId': number;
    /**
     * 
     * @type {ResourceFieldDto}
     * @memberof ActivityUpdateSuccessResponse
     */
    'resource': ResourceFieldDto;
    /**
     * 
     * @type {number}
     * @memberof ActivityUpdateSuccessResponse
     */
    'timeSpent': number;
    /**
     * 
     * @type {string}
     * @memberof ActivityUpdateSuccessResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityUpdateSuccessResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActivityUpdateSuccessResponse
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CategoryCreateErrorResponse
 */
export interface CategoryCreateErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof CategoryCreateErrorResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface CategoryCreateRequest
 */
export interface CategoryCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateRequest
     */
    'type'?: CategoryCreateRequestTypeEnum;
}

export const CategoryCreateRequestTypeEnum = {
    Distracting: 'distracting',
    Neutral: 'neutral',
    Productive: 'productive'
} as const;

export type CategoryCreateRequestTypeEnum = typeof CategoryCreateRequestTypeEnum[keyof typeof CategoryCreateRequestTypeEnum];

/**
 * 
 * @export
 * @interface CategoryCreateSuccessResponse
 */
export interface CategoryCreateSuccessResponse {
    /**
     * 
     * @type {number}
     * @memberof CategoryCreateSuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CategoryCreateSuccessResponse
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateSuccessResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateSuccessResponse
     */
    'type'?: CategoryCreateSuccessResponseTypeEnum;
}

export const CategoryCreateSuccessResponseTypeEnum = {
    Distracting: 'distracting',
    Neutral: 'neutral',
    Productive: 'productive'
} as const;

export type CategoryCreateSuccessResponseTypeEnum = typeof CategoryCreateSuccessResponseTypeEnum[keyof typeof CategoryCreateSuccessResponseTypeEnum];

/**
 * 
 * @export
 * @interface CategoryErrorResponse
 */
export interface CategoryErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof CategoryErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof CategoryErrorResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface CategorySuccessResponse
 */
export interface CategorySuccessResponse {
    /**
     * 
     * @type {number}
     * @memberof CategorySuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CategorySuccessResponse
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof CategorySuccessResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategorySuccessResponse
     */
    'type'?: CategorySuccessResponseTypeEnum;
}

export const CategorySuccessResponseTypeEnum = {
    Distracting: 'distracting',
    Neutral: 'neutral',
    Productive: 'productive'
} as const;

export type CategorySuccessResponseTypeEnum = typeof CategorySuccessResponseTypeEnum[keyof typeof CategorySuccessResponseTypeEnum];

/**
 * 
 * @export
 * @interface CategoryUpdateErrorResponse
 */
export interface CategoryUpdateErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdateErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdateErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof CategoryUpdateErrorResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface CategoryUpdateRequest
 */
export interface CategoryUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof CategoryUpdateRequest
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdateRequest
     */
    'type'?: CategoryUpdateRequestTypeEnum;
}

export const CategoryUpdateRequestTypeEnum = {
    Distracting: 'distracting',
    Neutral: 'neutral',
    Productive: 'productive'
} as const;

export type CategoryUpdateRequestTypeEnum = typeof CategoryUpdateRequestTypeEnum[keyof typeof CategoryUpdateRequestTypeEnum];

/**
 * 
 * @export
 * @interface CategoryUpdateSuccessResponse
 */
export interface CategoryUpdateSuccessResponse {
    /**
     * 
     * @type {number}
     * @memberof CategoryUpdateSuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CategoryUpdateSuccessResponse
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdateSuccessResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdateSuccessResponse
     */
    'type'?: CategoryUpdateSuccessResponseTypeEnum;
}

export const CategoryUpdateSuccessResponseTypeEnum = {
    Distracting: 'distracting',
    Neutral: 'neutral',
    Productive: 'productive'
} as const;

export type CategoryUpdateSuccessResponseTypeEnum = typeof CategoryUpdateSuccessResponseTypeEnum[keyof typeof CategoryUpdateSuccessResponseTypeEnum];

/**
 * 
 * @export
 * @interface LoginFailedResponse
 */
export interface LoginFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof LoginFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof LoginFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginSuccessResponse
 */
export interface LoginSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginSuccessResponse
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginSuccessResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RefreshAuthFailedResponse
 */
export interface RefreshAuthFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshAuthFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshAuthFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof RefreshAuthFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface RefreshAuthSuccessResponse
 */
export interface RefreshAuthSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshAuthSuccessResponse
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshAuthSuccessResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RegisterFailedResponse
 */
export interface RegisterFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof RegisterFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RegisterSuccessResponse
 */
export interface RegisterSuccessResponse {
    /**
     * 
     * @type {number}
     * @memberof RegisterSuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RegisterSuccessResponse
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterSuccessResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterSuccessResponse
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ResourceCategoryFieldDto
 */
export interface ResourceCategoryFieldDto {
    /**
     * 
     * @type {number}
     * @memberof ResourceCategoryFieldDto
     */
    'id': number | null;
    /**
     * 
     * @type {string}
     * @memberof ResourceCategoryFieldDto
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ResourceCategoryFieldDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ResourceDeleteFailedResponse
 */
export interface ResourceDeleteFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof ResourceDeleteFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDeleteFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ResourceDeleteFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface ResourceDeleteRequest
 */
export interface ResourceDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof ResourceDeleteRequest
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ResourceFailedResponse
 */
export interface ResourceFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof ResourceFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ResourceFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface ResourceFieldDto
 */
export interface ResourceFieldDto {
    /**
     * 
     * @type {number}
     * @memberof ResourceFieldDto
     */
    'id': number | null;
    /**
     * 
     * @type {string}
     * @memberof ResourceFieldDto
     */
    'uri': string | null;
    /**
     * 
     * @type {ResourceCategoryFieldDto}
     * @memberof ResourceFieldDto
     */
    'category': ResourceCategoryFieldDto | null;
}
/**
 * 
 * @export
 * @interface ResourceSuccessResponse
 */
export interface ResourceSuccessResponse {
    /**
     * 
     * @type {CategorySuccessResponse}
     * @memberof ResourceSuccessResponse
     */
    'category': CategorySuccessResponse;
    /**
     * 
     * @type {number}
     * @memberof ResourceSuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResourceSuccessResponse
     */
    'uri': string;
}
/**
 * 
 * @export
 * @interface ResourceUpdateFailedResponse
 */
export interface ResourceUpdateFailedResponse {
    /**
     * 
     * @type {string}
     * @memberof ResourceUpdateFailedResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUpdateFailedResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ResourceUpdateFailedResponse
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface ResourceUpdateRequest
 */
export interface ResourceUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceUpdateRequest
     */
    'uri': string;
    /**
     * 
     * @type {number}
     * @memberof ResourceUpdateRequest
     */
    'categoryId': number;
}
/**
 * 
 * @export
 * @interface ResourceUpdateSuccessResponse
 */
export interface ResourceUpdateSuccessResponse {
    /**
     * 
     * @type {CategorySuccessResponse}
     * @memberof ResourceUpdateSuccessResponse
     */
    'category': CategorySuccessResponse;
    /**
     * 
     * @type {number}
     * @memberof ResourceUpdateSuccessResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResourceUpdateSuccessResponse
     */
    'uri': string;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создаёт новую активность для текущего авторизованного пользователя
         * @summary Создание новой активности
         * @param {ActivityCreateRequest} activityCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity: async (activityCreateRequest: ActivityCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityCreateRequest' is not null or undefined
            assertParamExists('createActivity', 'activityCreateRequest', activityCreateRequest)
            const localVarPath = `/api/v1/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет активность, если она была создана текущим авторизованным пользователем
         * @summary Удаляет активность по её id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteActivity', 'id', id)
            const localVarPath = `/api/v1/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список активностей, созданных текущим авторизованным пользователем
         * @summary Получение всех активностей
         * @param {FindActivitiesPeriodEnum} [period] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findActivities: async (period?: FindActivitiesPeriodEnum, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает активность по id, если она создана текущим авторизованным пользователем
         * @summary Получение активности по её id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findActivity: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findActivity', 'id', id)
            const localVarPath = `/api/v1/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет свойства активности, если она была создана текущим авторизованным пользователем
         * @summary Изменяет свойства активности
         * @param {ActivityUpdateRequest} activityUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity: async (activityUpdateRequest: ActivityUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityUpdateRequest' is not null or undefined
            assertParamExists('updateActivity', 'activityUpdateRequest', activityUpdateRequest)
            const localVarPath = `/api/v1/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * Создаёт новую активность для текущего авторизованного пользователя
         * @summary Создание новой активности
         * @param {ActivityCreateRequest} activityCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivity(activityCreateRequest: ActivityCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityCreateSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivity(activityCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.createActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет активность, если она была создана текущим авторизованным пользователем
         * @summary Удаляет активность по её id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActivity(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivity(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.deleteActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает список активностей, созданных текущим авторизованным пользователем
         * @summary Получение всех активностей
         * @param {FindActivitiesPeriodEnum} [period] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findActivities(period?: FindActivitiesPeriodEnum, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivitySuccessResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findActivities(period, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.findActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает активность по id, если она создана текущим авторизованным пользователем
         * @summary Получение активности по её id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findActivity(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivitySuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findActivity(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.findActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Изменяет свойства активности, если она была создана текущим авторизованным пользователем
         * @summary Изменяет свойства активности
         * @param {ActivityUpdateRequest} activityUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActivity(activityUpdateRequest: ActivityUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityUpdateSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivity(activityUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.updateActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * Создаёт новую активность для текущего авторизованного пользователя
         * @summary Создание новой активности
         * @param {ActivityCreateRequest} activityCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(activityCreateRequest: ActivityCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ActivityCreateSuccessResponse> {
            return localVarFp.createActivity(activityCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет активность, если она была создана текущим авторизованным пользователем
         * @summary Удаляет активность по её id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteActivity(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает список активностей, созданных текущим авторизованным пользователем
         * @summary Получение всех активностей
         * @param {FindActivitiesPeriodEnum} [period] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findActivities(period?: FindActivitiesPeriodEnum, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActivitySuccessResponse>> {
            return localVarFp.findActivities(period, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает активность по id, если она создана текущим авторизованным пользователем
         * @summary Получение активности по её id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findActivity(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ActivitySuccessResponse> {
            return localVarFp.findActivity(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Изменяет свойства активности, если она была создана текущим авторизованным пользователем
         * @summary Изменяет свойства активности
         * @param {ActivityUpdateRequest} activityUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity(activityUpdateRequest: ActivityUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ActivityUpdateSuccessResponse> {
            return localVarFp.updateActivity(activityUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * Создаёт новую активность для текущего авторизованного пользователя
     * @summary Создание новой активности
     * @param {ActivityCreateRequest} activityCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public createActivity(activityCreateRequest: ActivityCreateRequest, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).createActivity(activityCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет активность, если она была создана текущим авторизованным пользователем
     * @summary Удаляет активность по её id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public deleteActivity(id: number, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).deleteActivity(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает список активностей, созданных текущим авторизованным пользователем
     * @summary Получение всех активностей
     * @param {FindActivitiesPeriodEnum} [period] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public findActivities(period?: FindActivitiesPeriodEnum, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).findActivities(period, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает активность по id, если она создана текущим авторизованным пользователем
     * @summary Получение активности по её id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public findActivity(id: number, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).findActivity(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Изменяет свойства активности, если она была создана текущим авторизованным пользователем
     * @summary Изменяет свойства активности
     * @param {ActivityUpdateRequest} activityUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public updateActivity(activityUpdateRequest: ActivityUpdateRequest, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).updateActivity(activityUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindActivitiesPeriodEnum = {
    Today: 'today',
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;
export type FindActivitiesPeriodEnum = typeof FindActivitiesPeriodEnum[keyof typeof FindActivitiesPeriodEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверяет логин и пароль пользователя и возвращает jwt токен
         * @summary Вход пользователя
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Проверяет jwt токен и возвращает новый
         * @summary Обновление сессии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создаёт нового пользователя по имени и паролю
         * @summary Регистрация нового пользователя
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/api/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверяет логин и пароль пользователя и возвращает jwt токен
         * @summary Вход пользователя
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Проверяет jwt токен и возвращает новый
         * @summary Обновление сессии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshAuthSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создаёт нового пользователя по имени и паролю
         * @summary Регистрация нового пользователя
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Проверяет логин и пароль пользователя и возвращает jwt токен
         * @summary Вход пользователя
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginSuccessResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Проверяет jwt токен и возвращает новый
         * @summary Обновление сессии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(options?: RawAxiosRequestConfig): AxiosPromise<RefreshAuthSuccessResponse> {
            return localVarFp.refresh(options).then((request) => request(axios, basePath));
        },
        /**
         * Создаёт нового пользователя по имени и паролю
         * @summary Регистрация нового пользователя
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<RegisterSuccessResponse> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Проверяет логин и пароль пользователя и возвращает jwt токен
     * @summary Вход пользователя
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Проверяет jwt токен и возвращает новый
     * @summary Обновление сессии
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refresh(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создаёт нового пользователя по имени и паролю
     * @summary Регистрация нового пользователя
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создаёт новую категорию для текущего авторизованного пользователя
         * @summary Создание новой категории
         * @param {CategoryCreateRequest} categoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (categoryCreateRequest: CategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryCreateRequest' is not null or undefined
            assertParamExists('createCategory', 'categoryCreateRequest', categoryCreateRequest)
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет категорию, если она была создана текущим авторизованным пользователем
         * @summary Удаляет категорию
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список категорий, созданных текущим авторизованным пользователем
         * @summary Получение всех категорий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает категорию по id, если она создана текущим авторизованным пользователем
         * @summary Получение категории по её id
         * @param {number} id id категории
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategory: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создаёт новые категории по-умолчанию для текущего авторизованного пользователя
         * @summary Создание новых категорий по-умолчанию
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initDefault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories/init-default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет все категории, если они были создана текущим авторизованным пользователем
         * @summary Удаляет все категории
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCategories: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('resetCategories', 'loginRequest', loginRequest)
            const localVarPath = `/api/v1/categories/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменяет свойства категории, если она была создана текущим авторизованным пользователем
         * @summary Изменяет свойства категории
         * @param {CategoryUpdateRequest} categoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (categoryUpdateRequest: CategoryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryUpdateRequest' is not null or undefined
            assertParamExists('updateCategory', 'categoryUpdateRequest', categoryUpdateRequest)
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Создаёт новую категорию для текущего авторизованного пользователя
         * @summary Создание новой категории
         * @param {CategoryCreateRequest} categoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(categoryCreateRequest: CategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryCreateSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(categoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.createCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет категорию, если она была создана текущим авторизованным пользователем
         * @summary Удаляет категорию
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.deleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает список категорий, созданных текущим авторизованным пользователем
         * @summary Получение всех категорий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategorySuccessResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.findCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает категорию по id, если она создана текущим авторизованным пользователем
         * @summary Получение категории по её id
         * @param {number} id id категории
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCategory(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.findCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создаёт новые категории по-умолчанию для текущего авторизованного пользователя
         * @summary Создание новых категорий по-умолчанию
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initDefault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryCreateSuccessResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initDefault(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.initDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет все категории, если они были создана текущим авторизованным пользователем
         * @summary Удаляет все категории
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetCategories(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetCategories(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.resetCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Изменяет свойства категории, если она была создана текущим авторизованным пользователем
         * @summary Изменяет свойства категории
         * @param {CategoryUpdateRequest} categoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(categoryUpdateRequest: CategoryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryUpdateSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(categoryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.updateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Создаёт новую категорию для текущего авторизованного пользователя
         * @summary Создание новой категории
         * @param {CategoryCreateRequest} categoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(categoryCreateRequest: CategoryCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryCreateSuccessResponse> {
            return localVarFp.createCategory(categoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет категорию, если она была создана текущим авторизованным пользователем
         * @summary Удаляет категорию
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает список категорий, созданных текущим авторизованным пользователем
         * @summary Получение всех категорий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategories(options?: RawAxiosRequestConfig): AxiosPromise<Array<CategorySuccessResponse>> {
            return localVarFp.findCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает категорию по id, если она создана текущим авторизованным пользователем
         * @summary Получение категории по её id
         * @param {number} id id категории
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategory(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CategorySuccessResponse> {
            return localVarFp.findCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Создаёт новые категории по-умолчанию для текущего авторизованного пользователя
         * @summary Создание новых категорий по-умолчанию
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initDefault(options?: RawAxiosRequestConfig): AxiosPromise<Array<CategoryCreateSuccessResponse>> {
            return localVarFp.initDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет все категории, если они были создана текущим авторизованным пользователем
         * @summary Удаляет все категории
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCategories(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetCategories(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Изменяет свойства категории, если она была создана текущим авторизованным пользователем
         * @summary Изменяет свойства категории
         * @param {CategoryUpdateRequest} categoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(categoryUpdateRequest: CategoryUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryUpdateSuccessResponse> {
            return localVarFp.updateCategory(categoryUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Создаёт новую категорию для текущего авторизованного пользователя
     * @summary Создание новой категории
     * @param {CategoryCreateRequest} categoryCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public createCategory(categoryCreateRequest: CategoryCreateRequest, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).createCategory(categoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет категорию, если она была создана текущим авторизованным пользователем
     * @summary Удаляет категорию
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategory(id: number, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).deleteCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает список категорий, созданных текущим авторизованным пользователем
     * @summary Получение всех категорий
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public findCategories(options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).findCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает категорию по id, если она создана текущим авторизованным пользователем
     * @summary Получение категории по её id
     * @param {number} id id категории
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public findCategory(id: number, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).findCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создаёт новые категории по-умолчанию для текущего авторизованного пользователя
     * @summary Создание новых категорий по-умолчанию
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public initDefault(options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).initDefault(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет все категории, если они были создана текущим авторизованным пользователем
     * @summary Удаляет все категории
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public resetCategories(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).resetCategories(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Изменяет свойства категории, если она была создана текущим авторизованным пользователем
     * @summary Изменяет свойства категории
     * @param {CategoryUpdateRequest} categoryUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateCategory(categoryUpdateRequest: CategoryUpdateRequest, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).updateCategory(categoryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаляет ресурс по id
         * @summary Удаление ресурса
         * @param {ResourceDeleteRequest} resourceDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResource: async (resourceDeleteRequest: ResourceDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceDeleteRequest' is not null or undefined
            assertParamExists('deleteResource', 'resourceDeleteRequest', resourceDeleteRequest)
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все ресурсы
         * @summary Получение всех ресурсов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает ресурс по id
         * @summary Получение ресурса по id
         * @param {number} id id ресурса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOne', 'id', id)
            const localVarPath = `/api/v1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет ресурс
         * @summary Обновление ресурса
         * @param {ResourceUpdateRequest} resourceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResource: async (resourceUpdateRequest: ResourceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceUpdateRequest' is not null or undefined
            assertParamExists('updateResource', 'resourceUpdateRequest', resourceUpdateRequest)
            const localVarPath = `/api/v1/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Удаляет ресурс по id
         * @summary Удаление ресурса
         * @param {ResourceDeleteRequest} resourceDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResource(resourceDeleteRequest: ResourceDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResource(resourceDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.deleteResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает все ресурсы
         * @summary Получение всех ресурсов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceSuccessResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.findAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает ресурс по id
         * @summary Получение ресурса по id
         * @param {number} id id ресурса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOne(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceSuccessResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.findOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет ресурс
         * @summary Обновление ресурса
         * @param {ResourceUpdateRequest} resourceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResource(resourceUpdateRequest: ResourceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceUpdateSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResource(resourceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.updateResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * Удаляет ресурс по id
         * @summary Удаление ресурса
         * @param {ResourceDeleteRequest} resourceDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResource(resourceDeleteRequest: ResourceDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteResource(resourceDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает все ресурсы
         * @summary Получение всех ресурсов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceSuccessResponse>> {
            return localVarFp.findAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает ресурс по id
         * @summary Получение ресурса по id
         * @param {number} id id ресурса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceSuccessResponse>> {
            return localVarFp.findOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет ресурс
         * @summary Обновление ресурса
         * @param {ResourceUpdateRequest} resourceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResource(resourceUpdateRequest: ResourceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResourceUpdateSuccessResponse> {
            return localVarFp.updateResource(resourceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * Удаляет ресурс по id
     * @summary Удаление ресурса
     * @param {ResourceDeleteRequest} resourceDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public deleteResource(resourceDeleteRequest: ResourceDeleteRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).deleteResource(resourceDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает все ресурсы
     * @summary Получение всех ресурсов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public findAll(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).findAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает ресурс по id
     * @summary Получение ресурса по id
     * @param {number} id id ресурса
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public findOne(id: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).findOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет ресурс
     * @summary Обновление ресурса
     * @param {ResourceUpdateRequest} resourceUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public updateResource(resourceUpdateRequest: ResourceUpdateRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).updateResource(resourceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



